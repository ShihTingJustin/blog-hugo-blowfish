<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Class-Component on Renderer</title><link>//localhost:1313/tags/class-component/</link><description>Recent content in Class-Component on Renderer</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>© 2024 Justin Huang</copyright><atom:link href="//localhost:1313/tags/class-component/index.xml" rel="self" type="application/rss+xml"/><item><title>[筆記]Reactjs.tw Meetup #14 | 都 2022 年了你可能還是不懂 useEffect | Zet</title><link>//localhost:1313/notes/2023-06-08-react-note-meetup-useeffect-from-zet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//localhost:1313/notes/2023-06-08-react-note-meetup-useeffect-from-zet/</guid><description>https://www.youtube.com/watch?v=v9M20STEjgc https://slides.com/tz5514/useeffect-guide
useState # 在 React，畫面是資料延伸的結果 eg. event handler
每一次 render 都有自己的 event handlers
在每一次 render 之間的 props &amp;amp; state 都是獨立、不互相影響的 在每一次 render 中的 props &amp;amp; state 永遠都會保持不變，例如該次函式執行的常數 event handlers 是以原始資料 (props &amp;amp; state) 延伸出來的另一種資料結果 因此，每一次 render 都有自己的 event handlers useEffect # 重要觀念 # 每一次 render 都有自己的 effects</description></item></channel></rss>