<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Deep on Renderer</title><link>//localhost:1313/tags/deep/</link><description>Recent content in Deep on Renderer</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>© 2024 Justin Huang</copyright><atom:link href="//localhost:1313/tags/deep/index.xml" rel="self" type="application/rss+xml"/><item><title>深拷貝</title><link>//localhost:1313/notes/2022-11-02-deep-copy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//localhost:1313/notes/2022-11-02-deep-copy/</guid><description>物件的深拷貝(深層複製)是指其屬性和複製的來源物件的屬性不共享相同的引用（指向相同的底層值）的副本。因此，當您更改來源或副本時，可以確保不會導致其他物件也發生更改；也就是說，您不會意外地對來源或副本造成預期之外的更改。這種行為與淺層複製的行為形成對比，在淺層複製中，對來源或副本的更改可能也會導致其他物件的更改（因為兩個物件共享相同的引用）。
structureClone # 簡介 # 實際上，瀏覽器本身就有很多地方需要深度複製例如﹔將資料儲存在 IndexedDB 時序列化和反序列化。利用 postMessage() 將資料傳給 Web Worker 等情境都需要類似的處理。而內部其實是使用一種稱為結構複製的演算法，過去這功能並沒有提供給開發者，但現在我們可以使用 structuredClone() 了。
功能與限制 # 結構複製解決了大部分 JSON.stringify() 的問題，可以使用遞迴資料結構，JS 內建型別，效能也不錯。
但還是有些限制
Prototypes﹔如果您使用 structuredClone() 複製某類別物件實例 Class Instance 您只會取得單純的物件不會包涵 prototype 的部分 Function﹔如果您的物件包涵了函式則會被移除 不可複製﹔有些值是不可複製的例如 Error 和 DOM 節點 其他深層複製方法 # Lodash 轉 JSON 字串再轉回來 const copy = JSON.</description></item></channel></rss>